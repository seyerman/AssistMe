In computer science, a "quaject" is an object-like data structure containing both data and code (or pointers to code), exposed as an interface in the form of "callentries", and can accept a list of callentries to other quajects for "callbacks" and "callouts". They were developed by Alexia Massalin in 1989 for the "Synthesis kernel", and named for the "Qua! Machine", a unique hardware platform built by Massalin. The origin of the term 'qua' is unclear; Massalin claims humorously that it is a sound made by koalas.

The main purpose of quajects is to provide an abstraction to manage self-modifying code, by allowing runtime code optimizing on a per-object basis. While the original Synthesis kernel required quajects to be written in hand-developed assembly language, this was done to avoid developing a complex compiler; Massalin noted that just-in-time compilation (JIT) for a high-level programming language that permits runtime code generation, as in Lisp or Smalltalk, can also apply this approach, though she also asserted that the complexity of such a compiler was likely to be prohibitive.

Quajects differ from more conventional objects in two key ways: first, they always use a form of the dependency injection pattern to manage both interfaces to other quajects, and continuations out of the quaject; the list of callentry references for this is part of quaject creation, and may be updated during the quaject's lifetime. Second, and more critically, a given quaject's set of methods can be unique to the specific quaject; methods for a type or class of quajects are stored as one or more templates, rather than as fixed code. While shared methods can be accessed through a common table of pointers, individual quajects can also have methods that are generated specifically to tailor the performance for that quaject's behavior.
